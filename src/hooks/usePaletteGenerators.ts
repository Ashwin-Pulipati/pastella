import {
  Color,
  GenerationStrategy,
  PaletteType,
  AiMode,
} from "@/types/pastelPalette.types";
import { useCallback } from "react";

interface UsePaletteGeneratorsProps {
  strategy: GenerationStrategy;
  paletteSize: number;
  paletteType: PaletteType;
  aiMode: AiMode;
  aiPrompt: string;
  selectedKeywords: string[];
  setCurrentPalette: React.Dispatch<React.SetStateAction<Color[]>>;
  setGenerationCount: React.Dispatch<React.SetStateAction<number>>;
  setIsGenerating: React.Dispatch<React.SetStateAction<boolean>>;
  showNotification: (msg: string) => void;
}

function usePaletteGenerators({
  strategy,
  paletteSize,
  paletteType,
  aiPrompt,
  selectedKeywords,
  setCurrentPalette,
  setGenerationCount,
  setIsGenerating,
  showNotification,
}: UsePaletteGeneratorsProps) {

  const generatePalette = useCallback(async () => {
    setIsGenerating(true);
    const prompt = `
You are an expert color palette designer specializing in beautiful, attractive, modern, futuristic, and soft pastel colors.
Your task is to generate a harmonically correct pastel color palette based on the user's request.

**Palette Constraints:**
- Color Harmony: ${strategy}
- Number of Colors: ${paletteSize}
- Palette Type: ${paletteType}
- User's Theme/Idea: "${
      aiPrompt ||
      selectedKeywords.join(", ") ||
      "A surprising and beautiful combination"
    }"

**Your Goal:**
Create the most aesthetically pleasing palette possible that fits the theme. You have complete creative freedom to invent entirely new pastel colors or draw inspiration from well-known pastel color names. The final result must be a cohesive, professional-quality palette.

**Output Format:**
The output MUST be a valid JSON object following this exact structure: {"palette": [{"name": "A Creative Color Name", "hex": "#RRGGBB"}]}
`;

    const payload = {
      contents: [{ role: "user", parts: [{ text: prompt }] }],
      generationConfig: {
        responseMimeType: "application/json",
        responseSchema: {
          type: "OBJECT",
          properties: {
            palette: {
              type: "ARRAY",
              items: {
                type: "OBJECT",
                properties: {
                  hex: { type: "STRING" },
                  name: { type: "STRING" },
                },
                required: ["hex", "name"],
              },
            },
          },
          required: ["palette"],
        },
      },
    };

    const apiKey = process.env.NEXT_PUBLIC_GEMINI_API_KEY;
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

    try {
      const response = await fetch(apiUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        throw new Error(`API request failed with status ${response.status}`);
      }

      const result = await response.json();
      const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;

      if (!jsonText) {
        console.error("Gemini Response was empty. Full API Result:", result);
        throw new Error("API returned an empty response.");
      }

      const parsedJson = JSON.parse(jsonText);

      if (parsedJson.palette && Array.isArray(parsedJson.palette)) {
        const newPalette = parsedJson.palette.map((c: Color) => ({
          name: c.name || c.hex.toUpperCase(),
          hex: c.hex,
        }));
        setCurrentPalette(newPalette);
        setGenerationCount((prev) => prev + 1);
        showNotification("Palette generated by AI!");
      } else {
        throw new Error("Invalid palette data in API response.");
      }
    } catch (error) {
      console.error("Error generating AI palette:", error);
      showNotification("AI generation failed. Please try again.");
    } finally {
      setIsGenerating(false);
    }
  }, [
    paletteSize,
    paletteType,
    strategy,
    aiPrompt,
    selectedKeywords,
    setCurrentPalette,
    setGenerationCount,
    setIsGenerating,
    showNotification,
  ]);

  return { generatePalette };
}

export default usePaletteGenerators;
